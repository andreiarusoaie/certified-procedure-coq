\documentclass[10pt,a4wide]{article}
%\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
%\geometry{a4wide}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage[affil-it]{authblk}
\usepackage{url}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{epstopdf}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}


\newcommand{\Ra}{\Rightarrow}
\newcommand{\rrule}[2]{{#1} \Ra{#2}}
\newcommand{\RL}{\textsc{rl}~}
\renewcommand{\S}{\mathcal{S}}
\newcommand{\failure}{\mathtt{failure}}
\newcommand{\success}{\mathtt{success}}
\newcommand{\FreeVars}{\mathit{FreeVars}}



\title{Proving soundness of a procedure for verifying RL Formulas in Coq}
\author{Andrei Arusoaie
\thanks{andrei.arusoaie@inria.fr}}
\affil{INRIA Lille-Nord Europe}
\date{}                                           % Activate to display a given date or no date

\begin{document}
\maketitle

\begin{abstract}
%It mainly consists in a language independent proof system whose rules can be applied to deduce 
In this paper we give a brief description of some ongoing work on proving the soundness of a procedure for verifying Reachability Logic properties in Coq. 
The procedure has been introduced in our previous work and it has been proved sound.
Reachability Logic is a formalism that can be used to state properties about program executions.
The procedure can be seen as an implementation of a strategy for applying the Reachability Logic's proof system.
Our objective is to implement this procedure in a way that it can generate certificates for proofs.
To this aim, we encode the procedure in Coq and we prove its soundness.
We report here the progress that we have made and the main difficulties that arise when dealing with such a proof.
\end{abstract}

\section{Introduction}
%\subsection{}

Reachability Logic~\cite{rosu-stefanescu-ciobaca-moore-2013-lics,rosu-stefanescu-2012-oopsla,rosu-stefanescu-2012-fm,stefanescu-ciobaca-mereuta-moore-serbanuta-rosu-2014-rta}  (\RL) is a formalism which can be used for stating properties about program execution and for specifying operational semantics of programming languages. 
It mainly consists of a language-independent proof system which has been shown sound and relatively complete. 
This proof system includes a special deduction rule which allows the use of a $\RL$ formula in its own proof.
\RL formulas are pairs of the form $\rrule{\varphi}{\varphi'}$, where $\varphi$, $\varphi'$ are called \emph{patterns} and they represent a set of states. 
A \RL formula denotes a \emph{reachability relation} between two such sets of states. 
A set of $\RL$ formulas generates a transition system over states, where two states are in the transition relation if the sets of states they belong to are in a reachability relation.
Depending on the interpretation of a formula, the reachability relation can express programming-language semantic steps, or properties over programs in the language in question. 



In previous work~\cite{vrlprls}, we proposed a procedure (Figure~\ref{fig:prove}) for verification of \RL properties and we proved it sound. 
The procedure \texttt{prove} can be regarded as an implementation of a certain strategy for applying the rules of the proof system of \RL.
Its benefit is that it allows us to mechanise the proving process.
Our objective is to implement \texttt{prove} in a way that it can be used, not only for verification of \RL formulas, but also for generating certificates.
To this aim, we have chosen the Coq system to both implement our procedure and generate certificates. 
This system fits our requirements because the implementation of \texttt{prove} in Coq can be extracted as certified OCaml code (which can be further used for verification) and also because it is able to generate certificates from proofs.
For the latter, we also need to encode in Coq the soundness of our procedure.



\begin{figure}[t]
\fontsize{9}{10}
\selectfont
\textbf{procedure} \texttt{prove}($\S,  G_0, G$)  
\begin{itemize}
\item[1:] \textbf{if} $G = \emptyset$ \textbf{then return} $\success$ 
\item[2:] \quad \textbf{\textbf{else} \textbf{choose} $\rrule{\varphi}{\varphi'} \in G$}  
\item[3:] \quad \quad \textbf{if} $M\models \varphi \rightarrow \varphi'$ \textbf{then return} \texttt{prove}($\S, G_0, G\setminus \{ \rrule{\varphi}{\varphi'} \}$)  
\item[4:] \quad \quad \textbf{else} \textbf{if} there is $ \rrule{\varphi_c}{\varphi'_c} \in G_0$ s. t. $M\models\varphi\implies (\exists\FreeVars(\varphi_c))\varphi_c$ 
%\vr{pt weak completeness as avea nevoie de adaugarea conditiei  $\rarule{\varphi}{\varphi'} \ma{is \ \{\rarule{\varphi_c}{\varphi'_c}\}\mbox{-} derivable}$.}
\textbf{then}   
\item[5:] \qquad \qquad
\textbf{return} \texttt{prove}($\S,G_0,G\setminus \{ \rrule{\varphi}{\varphi'} \}  \cup \Delta_{\rrule{\varphi_c}{\varphi'_c}}(\rrule{\varphi}{\varphi'}) $) 
\item[6:] \quad \quad \textbf{else if}  $\varphi$ is $\S$-derivable \textbf{then}
\item[7:] \qquad \qquad
\textbf{return} \texttt{prove}($\S,G_0,G\setminus \{ \rrule{\varphi}{\varphi'}  \} \cup\Delta_{\S}(\rrule{\varphi}{\varphi'}) $)
\item[8:] \quad \quad \textbf{else return} $\failure$.
\end{itemize}
\caption{\label{fig:prove} \RL verification procedure.}
\end{figure}


\section{Proving soundness in Coq}

The soundness result for our procedure is stated and proved in~\cite{vrlprls}. 
It essentially says that if \texttt{prove} returns $\success$ then the transition system generated by the input $\S$ (a set of \RL formulas, usually representing an operational semantics) satisfies all the goals in $G_0$ (a set of \RL formulas representing the goals to be proved). 
A charateristic feature of \RL is that the initial goals $G_0$ can be used in the proof of other goals or in their own proofs.
The only restriction is to do at least one deduction step using an \RL formula from $\S$ before applying goals from $G_0$.
Thus, when calling \texttt{prove} we initially set the third argument, namely $G$, to be the set of goals derived from $G_0$ using $\S$.
When running, the procedure chooses a goal $\rrule{\varphi}{\varphi'}$ from the current set of goals $G$ and either eliminates it completely from $G$, or replaces it with a set of new goals under some conditions.  
If none of these conditions holds then $\failure$ is returned.

In order to prove the soundness in Coq we have to face a series of challenges raised by the procedure itself. 

First, the procedure might not terminate. 
For instance, this might happen when $G_0$ contains a single goal which cannot be used in its own proof and the procedure keeps applying formulas from $\S$.
Since Coq does not accept functions that do not terminate, we have to introduce a new parameter which is intended to limit the number of recursive calls.

Second, the proof in~\cite{vrlprls} is based on an additional construction which stores all the intermediate information generated by the recursive calls of \texttt{prove}. 
However, in practice, storing all that information might be very inefficient, especially if we take into account that fact that we need this information only for soundness. 
Thus, we have to find a way to handle that intermediate information in Coq such that it is used only when proving soundness.

Another issue here is that the intermediate information is said to be generated by each recursive call of \texttt{prove}. However, there is no explicit (formally defined) link between each recursive call and the corresponding generated information. Thus, we have to add the missing parts to the proof before encoding it into Coq. 

Finally, a more general  issue is that the formal background needed to encode \texttt{prove} in Coq is quite large. Also, some of the lemmas needed by the proof are very complex and have to be broken into several pieces to be amenable for the Coq proof.

\paragraph{Future work}
Currently, we introduced all the needed definitions in Coq and we adapted and stated our lemmas in Coq. Moreover, we adapted the proofs of the lemmas such that they can be easily encoded and we are in the process of proving them in Coq. After proving the soundness, we want to integrate our procedure into a tool, such that we can use the existing operational semantics of real-life programming languages (e.g.~\cite{ellison-rosu-2012-popl},\cite{bogdanas-rosu-2015-popl}, \ldots) for verifying programs written in those languages. 
This will also require some translation of the semantics into Coq. 
In the end, we aim that this tool will accept specifications of program properties (in the form of \RL formulas) as input, and it will  output the result of the verification, accompanied by a certificate (in case it ended successfully).


\bibliographystyle{plain}
\bibliography{paper}

\end{document}  